/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeHtmlToPdfPDFOptions

template <typename P0, typename P1, typename P2, typename P3, typename P4, typename P5, typename P6, typename P7, typename P8, typename P9, typename P10, typename P11, typename P12, typename P13>
struct NativeHtmlToPdfPDFOptions {
  P0 html;
  P1 fileName;
  P2 width;
  P3 height;
  P4 base64;
  P5 padding;
  P6 paddingTop;
  P7 paddingBottom;
  P8 paddingLeft;
  P9 paddingRight;
  P10 bgColor;
  P11 directory;
  P12 baseURL;
  P13 shouldPrintBackgrounds;
  bool operator==(const NativeHtmlToPdfPDFOptions &other) const {
    return html == other.html && fileName == other.fileName && width == other.width && height == other.height && base64 == other.base64 && padding == other.padding && paddingTop == other.paddingTop && paddingBottom == other.paddingBottom && paddingLeft == other.paddingLeft && paddingRight == other.paddingRight && bgColor == other.bgColor && directory == other.directory && baseURL == other.baseURL && shouldPrintBackgrounds == other.shouldPrintBackgrounds;
  }
};

template <typename T>
struct NativeHtmlToPdfPDFOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.html)>(rt, value.getProperty(rt, "html"), jsInvoker),
      bridging::fromJs<decltype(types.fileName)>(rt, value.getProperty(rt, "fileName"), jsInvoker),
      bridging::fromJs<decltype(types.width)>(rt, value.getProperty(rt, "width"), jsInvoker),
      bridging::fromJs<decltype(types.height)>(rt, value.getProperty(rt, "height"), jsInvoker),
      bridging::fromJs<decltype(types.base64)>(rt, value.getProperty(rt, "base64"), jsInvoker),
      bridging::fromJs<decltype(types.padding)>(rt, value.getProperty(rt, "padding"), jsInvoker),
      bridging::fromJs<decltype(types.paddingTop)>(rt, value.getProperty(rt, "paddingTop"), jsInvoker),
      bridging::fromJs<decltype(types.paddingBottom)>(rt, value.getProperty(rt, "paddingBottom"), jsInvoker),
      bridging::fromJs<decltype(types.paddingLeft)>(rt, value.getProperty(rt, "paddingLeft"), jsInvoker),
      bridging::fromJs<decltype(types.paddingRight)>(rt, value.getProperty(rt, "paddingRight"), jsInvoker),
      bridging::fromJs<decltype(types.bgColor)>(rt, value.getProperty(rt, "bgColor"), jsInvoker),
      bridging::fromJs<decltype(types.directory)>(rt, value.getProperty(rt, "directory"), jsInvoker),
      bridging::fromJs<decltype(types.baseURL)>(rt, value.getProperty(rt, "baseURL"), jsInvoker),
      bridging::fromJs<decltype(types.shouldPrintBackgrounds)>(rt, value.getProperty(rt, "shouldPrintBackgrounds"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String htmlToJs(jsi::Runtime &rt, decltype(types.html) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String fileNameToJs(jsi::Runtime &rt, decltype(types.fileName) value) {
    return bridging::toJs(rt, value);
  }

  static double widthToJs(jsi::Runtime &rt, decltype(types.width) value) {
    return bridging::toJs(rt, value);
  }

  static double heightToJs(jsi::Runtime &rt, decltype(types.height) value) {
    return bridging::toJs(rt, value);
  }

  static bool base64ToJs(jsi::Runtime &rt, decltype(types.base64) value) {
    return bridging::toJs(rt, value);
  }

  static double paddingToJs(jsi::Runtime &rt, decltype(types.padding) value) {
    return bridging::toJs(rt, value);
  }

  static double paddingTopToJs(jsi::Runtime &rt, decltype(types.paddingTop) value) {
    return bridging::toJs(rt, value);
  }

  static double paddingBottomToJs(jsi::Runtime &rt, decltype(types.paddingBottom) value) {
    return bridging::toJs(rt, value);
  }

  static double paddingLeftToJs(jsi::Runtime &rt, decltype(types.paddingLeft) value) {
    return bridging::toJs(rt, value);
  }

  static double paddingRightToJs(jsi::Runtime &rt, decltype(types.paddingRight) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String bgColorToJs(jsi::Runtime &rt, decltype(types.bgColor) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String directoryToJs(jsi::Runtime &rt, decltype(types.directory) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String baseURLToJs(jsi::Runtime &rt, decltype(types.baseURL) value) {
    return bridging::toJs(rt, value);
  }

  static bool shouldPrintBackgroundsToJs(jsi::Runtime &rt, decltype(types.shouldPrintBackgrounds) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "html", bridging::toJs(rt, value.html, jsInvoker));
    if (value.fileName) {
      result.setProperty(rt, "fileName", bridging::toJs(rt, value.fileName.value(), jsInvoker));
    }
    if (value.width) {
      result.setProperty(rt, "width", bridging::toJs(rt, value.width.value(), jsInvoker));
    }
    if (value.height) {
      result.setProperty(rt, "height", bridging::toJs(rt, value.height.value(), jsInvoker));
    }
    if (value.base64) {
      result.setProperty(rt, "base64", bridging::toJs(rt, value.base64.value(), jsInvoker));
    }
    if (value.padding) {
      result.setProperty(rt, "padding", bridging::toJs(rt, value.padding.value(), jsInvoker));
    }
    if (value.paddingTop) {
      result.setProperty(rt, "paddingTop", bridging::toJs(rt, value.paddingTop.value(), jsInvoker));
    }
    if (value.paddingBottom) {
      result.setProperty(rt, "paddingBottom", bridging::toJs(rt, value.paddingBottom.value(), jsInvoker));
    }
    if (value.paddingLeft) {
      result.setProperty(rt, "paddingLeft", bridging::toJs(rt, value.paddingLeft.value(), jsInvoker));
    }
    if (value.paddingRight) {
      result.setProperty(rt, "paddingRight", bridging::toJs(rt, value.paddingRight.value(), jsInvoker));
    }
    if (value.bgColor) {
      result.setProperty(rt, "bgColor", bridging::toJs(rt, value.bgColor.value(), jsInvoker));
    }
    if (value.directory) {
      result.setProperty(rt, "directory", bridging::toJs(rt, value.directory.value(), jsInvoker));
    }
    if (value.baseURL) {
      result.setProperty(rt, "baseURL", bridging::toJs(rt, value.baseURL.value(), jsInvoker));
    }
    if (value.shouldPrintBackgrounds) {
      result.setProperty(rt, "shouldPrintBackgrounds", bridging::toJs(rt, value.shouldPrintBackgrounds.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeHtmlToPdfPDFResult

template <typename P0, typename P1, typename P2>
struct NativeHtmlToPdfPDFResult {
  P0 filePath;
  P1 base64;
  P2 numberOfPages;
  bool operator==(const NativeHtmlToPdfPDFResult &other) const {
    return filePath == other.filePath && base64 == other.base64 && numberOfPages == other.numberOfPages;
  }
};

template <typename T>
struct NativeHtmlToPdfPDFResultBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.filePath)>(rt, value.getProperty(rt, "filePath"), jsInvoker),
      bridging::fromJs<decltype(types.base64)>(rt, value.getProperty(rt, "base64"), jsInvoker),
      bridging::fromJs<decltype(types.numberOfPages)>(rt, value.getProperty(rt, "numberOfPages"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String filePathToJs(jsi::Runtime &rt, decltype(types.filePath) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String base64ToJs(jsi::Runtime &rt, decltype(types.base64) value) {
    return bridging::toJs(rt, value);
  }

  static double numberOfPagesToJs(jsi::Runtime &rt, decltype(types.numberOfPages) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "filePath", bridging::toJs(rt, value.filePath, jsInvoker));
    if (value.base64) {
      result.setProperty(rt, "base64", bridging::toJs(rt, value.base64.value(), jsInvoker));
    }
    if (value.numberOfPages) {
      result.setProperty(rt, "numberOfPages", bridging::toJs(rt, value.numberOfPages.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeHtmlToPdfCxxSpecJSI : public TurboModule {
protected:
  NativeHtmlToPdfCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value convert(jsi::Runtime &rt, jsi::Object options) = 0;

};

template <typename T>
class JSI_EXPORT NativeHtmlToPdfCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "HtmlToPdf";

protected:
  NativeHtmlToPdfCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeHtmlToPdfCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeHtmlToPdfCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeHtmlToPdfCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value convert(jsi::Runtime &rt, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::convert) == 2,
          "Expected convert(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::convert, jsInvoker_, instance_, std::move(options));
    }

  private:
    friend class NativeHtmlToPdfCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
